## Problema

17 - Usando as interfaces nativas do C# para implementação do 
_Observer pattern_, nomeadamente `IObserver<T>` e `IObservable<T>`, implementa:

1. Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
de modo a que não apareça no ecrã) e notifique os observadores cada vez 
que uma tecla é premida.
2. Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla 'R'`).
3. Um observador que guarde o carácter associado à tecla 
num ficheiro (em modo `append`).

O programa deve terminar quando for pressionada a tecla _Escape_.

## Soluções

### Solução 1

Class Program:

```cs
namespace Ex17
{
    public class Program
    {
        private static void Main(string[] args)
        {
            Subject subject = new Subject();
            AbstractObserver obsScreen = new ObserverScreen();
            AbstractObserver obsFile = new ObserverFile("ProgramOutput");

            // Add observers to collection
            subject.Subscribe(obsScreen);
            subject.Subscribe(obsFile);

            // Start loop
            subject.Execute();
        }
    }
}
```

Class Subject:

```cs
using System;
using System.Collections.Generic;

namespace Ex17
{
    public class Subject
    {
        public ConsoleKey LastKey { get; private set; }
        private ICollection<IObserver<AbstractObserver>> _observers;

        // Subject constructor, initializes list of IObserver
        public Subject()
        {
            _observers = new List<IObserver<AbstractObserver>>();
        }

        public IDisposable Subscribe(IObserver<AbstractObserver> observer)
        {
            if (!_observers.Contains(observer)) _observers.Add(observer);
            return new Unsubscriber(_observers, observer);
        }

        public void Execute()
        {
            // Every time a key is pressed...
            while (true)
            {
                // Get key while it isn't 'escape'
                LastKey = Console.ReadKey(true).Key;

                // Out of loop when 'escape' is pressed
                if (LastKey == ConsoleKey.Escape) break;

                // ...informs all observers in collection
                foreach (AbstractObserver o in _observers)
                {
                    o.OnNext(this);
                }
            }
        }

        // Internal class that inherits IDisposable
        private class Unsubscriber : IDisposable
        {
            private ICollection<IObserver<AbstractObserver>> _observers;
            private IObserver<AbstractObserver> _observer;

            // Constructor, accepts a collection of observers and an observer
            public Unsubscriber
                (ICollection<IObserver<AbstractObserver>> observers,
                IObserver<AbstractObserver> observer)
            {
                _observers = observers;
                _observer = observer;
            }

            public void Dispose()
            {
                if (_observer != null && _observers.Contains(_observer))
                    _observers.Remove(_observer);
            }
        }
    }
}
```

Class ObserverScreen:

```cs
using System;

namespace Ex17
{
    public class ObserverScreen : AbstractObserver
    {
        public override void OnNext(Subject subject)
        {
            // Outputs to screen the pressed key
            Console.WriteLine("Detetada a tecla: '"+ subject.LastKey+ "'");
        }
    }
}
```

Class ObserverFile:

```cs
using System.IO;

namespace Ex17
{
    public class ObserverFile : AbstractObserver
    {
        private string _filename;

        // Constructor, accepts a string
        // that corresponds to the file name created
        public ObserverFile(string filename)
        {
            _filename = filename;
        }

        public override void OnNext(Subject subject)
        {
            // Writes info (input) in a file
            File.AppendAllText(_filename, subject.LastKey.ToString());
        }
    }
}
```

Class AbstractObserver:

```cs
using System;
using System.Collections.Generic;

namespace Ex17
{
    public abstract class AbstractObserver : IObserver<Subject>, IObserver<AbstractObserver>
    {
        private ICollection<AbstractObserver> _observers;

        // Outputs message when program ends
        public virtual void OnCompleted()
        {
            Console.WriteLine("Unsubscribed");
            Unsubscribe();
        }

        // Outputs error message
        public void OnError(Exception error)
        {
            Console.WriteLine(error);
        }

        // To be overridden by classes that inherit this
        public abstract void OnNext(Subject subject);

        public void OnNext(AbstractObserver observer)
        {
            observer.ToString();
        }

        // Removes observer from list
        private void Unsubscribe()
        {
            _observers.Remove(this);
        }
    }
}
```

*Por [João Rebelo](https://github.com/JBernardoRebelo)*
