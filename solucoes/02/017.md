## Problema

17 - Usando as interfaces nativas do C# para implementação do 
_Observer pattern_, nomeadamente `IObserver<T>` e `IObservable<T>`, implementa:

1. Um sujeito/observável que leia teclas do teclado (suprimindo a tecla lida
de modo a que não apareça no ecrã) e notifique os observadores cada vez 
que uma tecla é premida.
2. Um observador que indique no ecrã a tecla lida (e.g. `Detetada tecla 'R'`).
3. Um observador que guarde o carácter associado à tecla 
num ficheiro (em modo `append`).

O programa deve terminar quando for pressionada a tecla _Escape_.

## Soluções

### Solução 1

`Class Program:`

```cs
namespace Ex17
{
    public class Program
    {
        private static void Main(string[] args)
        {
            Subject subject = new Subject();
            AbstractObserver obsScreen = new ObserverScreen();
            AbstractObserver obsFile = new ObserverFile("ProgramOutput");

            // Add observers to collection
            subject.Subscribe(obsScreen);
            subject.Subscribe(obsFile);

            // Start loop
            subject.Execute();
        }
    }
}
```

`Class Subject:`

```cs
using System;
using System.Collections.Generic;

namespace Ex17
{
    public class Subject : IObservable<AbstractObserver>
    {
        private ConsoleKey LastKey { get; set; }
        private ICollection<IObserver<AbstractObserver>> _observers;

        // Subject constructor, initializes list of IObserver
        public Subject()
        {
            _observers = new List<IObserver<AbstractObserver>>();
        }


        // Add an observer to the collection
        public IDisposable Subscribe(IObserver<AbstractObserver> observer)
        {
            if (!_observers.Contains(observer)) _observers.Add(observer);
            return new Unsubscriber(_observers, observer);
        }

        public void Execute()
        {
            // Every time a key is pressed...
            while (true)
            {
                // Get key while it isn't 'escape'
                LastKey = Console.ReadKey(true).Key;

                // Out of loop when 'escape' is pressed
                if (LastKey == ConsoleKey.Escape)
                {
                    foreach(AbstractObserver o in _observers)
                    {
                        o.OnCompleted();
                    }
                    break;
                }

                // ...informs all observers in collection
                foreach (AbstractObserver o in _observers)
                {
                    o.OnNext(LastKey);
                }
            }
        }

        // Internal class that inherits IDisposable
        private class Unsubscriber : IDisposable
        {
            private ICollection<IObserver<AbstractObserver>> _observers;
            private IObserver<AbstractObserver> _observer;

            // Constructor, accepts a collection of observers and an observer
            public Unsubscriber
                (ICollection<IObserver<AbstractObserver>> observers,
                IObserver<AbstractObserver> observer)
            {
                _observers = observers;
                _observer = observer;
            }

            // Removes an observer from the collection
            public void Dispose()
            {
                if (_observer != null && _observers.Contains(_observer))
                    _observers.Remove(_observer);
            }
        }
    }
}
```

`Class ObserverScreen:`

```cs
using System;

namespace Ex17
{
    public class ObserverScreen : AbstractObserver
    {
        public override void OnNext(ConsoleKey key)
        {
            // Outputs to screen the pressed key
            Console.WriteLine("Detetada a tecla: '"+ key+ "'");
        }
    }
}
```

`Class ObserverFile:`

```cs
using System;

namespace Ex17
{
    public class ObserverScreen : AbstractObserver
    {
        public override void OnNext(ConsoleKey key)
        {
            // Outputs to screen the pressed key
            Console.WriteLine("Detetada a tecla: '"+ key+ "'");
        }
    }
}
```

`Class ObserverFile:`

```cs
using System;
using System.IO;

namespace Ex17
{
    public class ObserverFile : AbstractObserver
    {
        private string _filename;

        // Constructor, accepts a string
        // that corresponds to the file name created
        public ObserverFile(string filename)
        {
            _filename = filename;
        }

        // Writes key on file
        public override void OnNext(ConsoleKey key)
        {
            // Writes info (input) in a file
            File.AppendAllText(_filename, key.ToString());
        }
    }
}
```

`Class AbstractObserver:`

```cs
using System;
using System.Collections.Generic;

namespace Ex17
{
    public abstract class AbstractObserver : IObserver<ConsoleKey>, 
        IObserver<AbstractObserver>
    {
        private ICollection<AbstractObserver> _observers;

        // Outputs message when program ends
        public virtual void OnCompleted()
        {
            Console.WriteLine(ToString() + " Unsubscribed");

            if (this == null)
            {
                _observers.Remove(this);
            }
        }

        // Outputs error message
        public void OnError(Exception error)
        {
            Console.WriteLine(error);
        }

        public abstract void OnNext(ConsoleKey key);

        public virtual void OnNext(AbstractObserver value)
        {
            throw new NotImplementedException();
        }
    }
}
```

*Por [João Rebelo](https://github.com/JBernardoRebelo)*
